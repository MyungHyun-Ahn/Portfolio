# Lock-Free Stack 02 - 디버깅
## 문제점 1
![test32](https://github.com/user-attachments/assets/113c1c34-6854-4e9e-b3b6-5d456c70a94c)
* double-free 문제가 발생

이 문제를 해결하기 위해 모든 Push와 Pop을 추적해보자
* 추적할 정보
  1. threadId
  2. push인지 pop인지
  3. data
  4. 읽은 top - 수행 대상
  5. newTop - 새로 Top이 되어야 하는 것
* 이런 정보를 모두 추적해서 확인

메모리에 데이터를 저장
![test33](https://github.com/user-attachments/assets/96d756e4-46fd-46a7-bd5e-4d80c4e95ab1)
* 저장한 값을 정리해봄
* 이런 상황이 어떤 시나리오로 발생했는지 알아보자

10 40 7e d3 48 01 00 00 주소를 지우다 Crash가 발생
* 요주의 주소

### 시나리오 추적
10 40 7e d3 48 01 00 00 주소를 어디서도 읽었는지 확인

![test34](https://github.com/user-attachments/assets/05b25466-9d5a-4bb9-99a2-7331ca72cd81)
* 한참 위의 로그

![test35](https://github.com/user-attachments/assets/d58678b6-ac3b-4460-ad70-41046847eb22)
* 바로 위

공통점
~~~txt
oldTop : 80 e5 81 d3 48 01 00 00 / newTop : 10 40 7e d3 48 01 00 00
~~~
* oldTop과 newTop을 두 스레드가 같은 것을 바라보고 Pop을 수행한 흔적이 있음
* 두 개의 threadId : 20 2e와 b8 24
  * 20 2e 스레드는 한참 위의 로그와 문제 지점 사이 로그 동안 수행되지 않았음
  * 즉, 컨텍스트 스위칭 혹은 블락 상태에 빠졌었음

20 2e 스레드가 위 정보를 보고 잠들어 있다 깨어나기 직전
* b8 24 스레드가 20 2e 스레드가 oldTop으로 보고 있던 주소를 Top으로 삽입해버림

### 상황 분석
1. [3] <- [2] <- [1]
   * 3이 TOP
   * 스레드 1과 2가 3을 oldTop, 2를 newTop으로 보고 있음
2. [2] <- [1]
   * 스레드 1은 성공
   * 스레드 2는 값을 읽은 상태로 블록에 빠짐(수행하지 못함)
3. 중간 과정 ... 스레드 1이 여러 작업을 진행
4. [N] <- ... <- [?]
   * [2]와 [1]은 삭제 되었을 수도 아닐수도 있음
5. [3] <- [N] ... <- [?]
   * 스레드 1이 노드를 할당 받아 삽입하였는데 주소가 재사용되어 3이 재삽입되고 Top이 되어버림
6. [2] <- [1]
   * 스레드 2가 깨어나고 oldTop이 3으로 읽었었음
   * oldTop이 3이고 현재 Top이 다시 3이므로
   * 어라..? 성공해버림(잘못된 성공)

ABA 문제라고도 함
* 데이터가 다시 할당되며 같은 주소가 재사용되므로 발생
* 고쳐야하는 버그임

## 문제점 2
![test36](https://github.com/user-attachments/assets/d192c08c-7823-48e9-a77f-c49483dc9b6c)
* 문제 상황이 잘 나타나지 않아 Sleep(0)을 삽입함
* load했던 top을 참조하는 과정에서 읽기 엑세스 위반이 발생함

t 포인터가 무엇을 가리키고 있는지 보자
![test37](https://github.com/user-attachments/assets/fcabfbd7-7cf3-4afe-9b21-343df2cc953d)
* ?? ?? 로 표시된 메모리 영역을 가리키고 있음
* 페이지 테이블이 세팅되지 않은 상태
  * Decommit된 메모리
* 즉, t가 삭제되고 해당 페이지의 매핑까지 해제된 상태임

어쩌다 이런 상황이?
1. oldTop을 Load함
2. 여기서 Sleep(0)을 통해 부하를 줌
    * 상황이 더 잘 나타나게 하기 위해
3. 이 시간 동안 oldTop이 참조하던 것이 다른 스레드의 Pop이 이것을 pop 해버림
4. 동시에 우연히 사용되지 않는 페이지이므로 페이지가 디커밋 되어버림
5. 따라서 oldTop을 로드했던 다른 스레드는 이것을 참조하려다 읽기 엑세스 위반이 발생함

## 해결 방법
### 문제점 1의 해결
* 할당된 노드의 구분이 필요함
  * 같은 주소로 할당되더라도
  * ID 값 부여가 필요

### 문제점 2의 해결
* 락프리 알고리즘에 사용되는 모든 노드는 메모리에 상주해야 함
  * 즉, 페이지가 해제되면 절대 안됨
  * 다음 방식을 사용 가능
    * 스마트 포인터 - 메모리가 참조 중이라면 해제 X
    * 메모리 풀 - 해제되더라도 메모리 풀 내에서 관리하므로 직접적인 해제 발생 X

### 다음 목표
* 위 문제점을 해결한 락 프리 스택 구현