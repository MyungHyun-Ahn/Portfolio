# Lock-Free Stack 01
## 락프리 알고리즘이란?
락프리를 알아보기 전에 스핀락을 먼저 보아야 함
* 락을 획득할 때까지 스핀을 돌면서 값을 원자적으로 확인하고 획득하였다면 임계영역에 진입하는 동기화 방식
* 스핀락이 이득을 볼 수 있는 경우는 "퀀텀(타임 슬라이스) 내에 획득하는 경우"
  * 컨텍스트 스위칭을 하지않고 임계영역에 진입해야 함
* 빠른 임계영역의 획득을 목적으로 하는 알고리즘임

그럼 락프리는?
* 모두가 동시에 동작을 수행함
* 그런데 여기서 단 1개의 스레드만이 성공하고 나머지는 실패로 처리
  * 실패한 것들은 재시도 함
* 실패할 것을 예상하고 시도하고 실패하면 처음부터 다시 하는 것
  * 성공할 가능성이 적더라도 그 작은 가능성을 바라보고 시도함

무슨 이득이?
* 사실 성능 차이는 별로 없다고 함
* 멀티 스레드의 디버깅 감각 향상 목적
* 어떤 상황에서 이득을 보는지도 찾아보자
    * 동기화가 걸리는 영역이 매우 작은 스택과 큐 같은 자료구조에서만 적용 가능

## 락프리 스택
### 일반적인 스택의 push, pop 코드(리스트 기반)
~~~Cpp
// 수도 코드임
Push(data)
{
    pNode = new Node;
    pNode->data = data;
    pNode->next = top;
    top = pNode;
}

Pop()
{
    top = top->next;
    // 데이터는 알아서 top꺼 리턴
}
~~~

여기서 멀티스레딩이라면 경합 발생 지역은
* top을 교체하는 부분
* 여기를 다른 방식으로 바꿔보자

### 기본적인 락프리 스택
~~~Cpp
Push(data)
{
    pNode = new Node;
    pNode->data = data;

    // 반복
    t = top; // 현재 top을 백업 - 이것을 바라보고 작업함
    pNode->next = t;
    if (top == t)
        top = pNode; // top과 읽은 top이 같다면 자신이 성공
        break;
}

Pop()
{
    // 반복
    t = top;
    newTop = t->next;
    if (t == top)
        top = newTop; // 성공
        break;

    // t의 데이터 리턴
}
~~~
* 위 비교와 top 대입 과정을 atomic 하게 하면 락프리 알고리즘임
  * Windows API에는 Interlocked 계열의 함수를 사용하면 됨
    * CAS 연산

### 다음 목표
위 방식으로 구현한 스택을 디버깅해보자
* 무조건 문제가 생김