# IOCP Echo Server 06 - WSASend 호출 시 직렬화 버퍼 여러개 등록
## 목적
기존의 방식
* User Message(직렬화 버퍼) -> Send RingBuffer -> TCP 송신 버퍼 -> TCP 스택
  * 그런데 Send 버퍼를 0으로 만들었기 때문에
* User Message(직렬화 버퍼) -> Send RingBuffer -> TCP 스택
  * TCP는 우리의 RingBuffer에 다이렉트 I/O를 통해 바로 접근
  * 복사 한번을 줄였음

바꾸고 싶은 방식
* RingBuffer 또한 없애고 싶은 것
* User Message -> TCP 스택
* 직렬화 버퍼를 바로 WSASend에 여러개를 등록하고 싶은 것
* 이때 TCP는 알아서 직렬화 버퍼를 이어붙여 가져감

지금은 직렬화 버퍼의 포인터를 그냥 링버퍼에 넣고 꺼내쓸 것임
* 나중에는 락프리 큐로 변경할 것임
* 지금 에코 서버 구조상 헤더 포함 10바이트의 메시지만 보냄
  * 포인터는 8바이트이므로 큰 변화는 없을 것

## 구현
### SendPacket()
* 인자로 받은 직렬화 버퍼의 포인터를 인큐함

### PostSend()
예외 처리 부분
* 기존에는 버퍼가 비어있음을 0으로 체크
* 이제는 포인터가 최소 단위 이르모 8바이트보다 적은 데이터가 들어있으면 예외처리 루틴으로 빠짐

WSABUF에 등록할 수
* WSASEND_MAX_BUFFER_COUNT로 정의한 상수 값만큼 배열을 선언
  * 이 값은 나중에 테스트를 통해 어디까지 사용하면 효율이 좋은지 결정해야 함
  * 일단 WSASend 자체의 콜 타임이 느리므로 줄이면 좋음
  * 그런데 내부에서 전달 받은 버퍼의 이어붙이는 시간 또한 고려는 해야함
  * 고민사항
* 지금 사용중인 버퍼 사이즈를 계산하고 포인터의 크기만큼 나눈 값과 정의된 값 중 작은 값을 사용
* 반복을 돌며 WSABUF를 등록

여기서 세션에 변수를 하나 추가함
* sendCount(전송 직렬화 버퍼 개수)
* 이것을 기억해뒀다가 Send 완료통지가 왔을 때 직렬화 버퍼를 해제함
* 비동기 I/O에서 완료통지는 무조건 모든 버퍼를 전송해야 오기 때문에 가능함
  * 논블락 I/O에서는 일부 성공 시 일부 전송 바이트만 반환될 수도 있음
* 따라서 기억해둔 sendCount 만큼 삭제를 진행해도 안전함

### SendCompleted()
위에서 Session에 정의한 sendCount 만큼 삭제를 진행함

## 여기까지 구현하고 테스트 결과
메모리 누수가 발생함
* 어째서??

RelesaeSession 부분에서 세션이 할당 해제될 때 디버깅 코드
~~~Cpp
if (pSession->m_SendBuffer.GetUseSize())
	__debugbreak();
~~~
* 해제될 때 sendBuffer가 비어있는지 체크
* 서버를 기동한지 얼마 안지나 중단점이 잡힘을 확인

따라서 이 시점에 SendBuffer에 남은 데이터가 있다면
* 할당 해제하고 세션 삭제를 진행함
* 여기 넘어온 타이밍이 ioCount가 0이 되고 넘어왔으므로 문제가 되지 않음
  * 다른 Send 요청이 걸렸을리 없음

### 다음 목표
* 비동기 Accept 해볼것